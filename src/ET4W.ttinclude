<#@ assembly name="System.Core"#>
<#@ assembly name="System.Xml"#>
<#@ assembly name="System.Runtime.Serialization"#>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text"#>
<#@ import namespace="System.Collections.Generic"#>
<#@ import namespace="System.Runtime.Serialization" #>
<#@ import namespace="System.Runtime.Serialization.Json" #>
<#@ import namespace="System.Diagnostics.Tracing" #>
<#@ import namespace="System.Globalization" #>
<#+
const string KeywordsClassName = "Keywords";
private void WriteEventSource(string eventsFile, string nameSpace, Type baseType = null)
{
	baseType = baseType ?? typeof(EventSource);
	EventDefinitions eventDefinitions = null;
	var dcjs = new DataContractJsonSerializer(typeof(EventDefinitions));

	//we don't use FileStream directly below in order to support UTF BOM headers
	using (var eventsStream = new MemoryStream(Encoding.UTF8.GetBytes(File.ReadAllText(eventsFile))))
    {
		eventDefinitions = (EventDefinitions)dcjs.ReadObject(eventsStream);
    }
	ValidateEventDefinitions(eventDefinitions);
	var eventClassName = eventDefinitions.Class + "Events"; 
	var eventSourceClassName = eventDefinitions.Class + "EventSource"; 
	var customTypeTargets = eventDefinitions.CustomTypes.ToDictionary(ct => ct.FullyQualifiedName, ct => ct.TargetType);
#>
//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// This code was automatically generated by ET4W (https://github.com/ohadschn/ET4W).
// Changes to this file might cause incorrect behavior and will be lost if the code is regenerated. 
// If you wish to customize the code, extend the generated partial events class in a separate file.
//
// Input file:			<#= eventsFile #>
// Generation time:		<#= DateTime.UtcNow.ToString("r") #>
//
// </auto-generated> 
//-------------------------------------------------------------------------------------------------

using System;
using System.Diagnostics.Tracing;

namespace <#= nameSpace #>
{
	public partial class <#= eventClassName #>
	{
<#+
		foreach (var customType in eventDefinitions.CustomTypes)
{#>
		<#= Util.GetConverterType(customType) #> m_<#= Util.GetConverterName(customType.FullyQualifiedName) #>;
<#+ } #>
		
		public <#= eventClassName #>(<#= String.Join(", ", eventDefinitions.CustomTypes.Select(ct => Util.FormatInvariant("{0} {1}", Util.GetConverterType(ct), Util.GetConverterName(ct.FullyQualifiedName)))) #>)
		{
<#+
		foreach (var customType in eventDefinitions.CustomTypes)
{#>
			m_<#= Util.GetConverterName(customType.FullyQualifiedName) #> = <#= Util.GetConverterName(customType.FullyQualifiedName) #>;
<#+ } #>
		}

<#+ 
		foreach (var evnt in eventDefinitions.Events)
{ #>
		public void <#= evnt.Name #>(<#= String.Join(", ", evnt.Parameters.Select(p => Util.FormatInvariant("{0} {1}", p.Type, p.Name))) #>)
		{
			<#= eventSourceClassName #>.Log.<#= evnt.Name #>(<#= String.Join(", ", evnt.Parameters.Select(p => Util.FormatInvariant("{0}({1})", p.IsCustomType ? "m_" + Util.GetConverterName(p.Type) : "" ,p.Name))) #>);
		}
<#+ } #>
	}

	[EventSource(Name = "<#= eventDefinitions.SourceName #>")]
	public sealed class <#= eventSourceClassName #> : <#= baseType.FullName #>
	{
		public static readonly <#= eventSourceClassName #> Log = new <#= eventSourceClassName #>();

		public sealed class Keywords
		{
			private Keywords() {}
<#+ 
	int keywordValue = 1;
	foreach (var keyword in eventDefinitions.Keywords)
    { #>
			public const EventKeywords <#= keyword #> = (EventKeywords) <#= keywordValue #>;
<#+ 
		keywordValue *= 2;
	} #>
		}

		public sealed class Tasks
		{
			private Tasks() {}
<#+ 
	int taskValue = 1;
	foreach (var keyword in eventDefinitions.Tasks)
    { #>
			public const EventTask <#= keyword #> = (EventTask) <#= taskValue++ #>;
<#+ } #>
		}

<#+ 
	foreach (var evnt in eventDefinitions.Events)
	{ #>
		[Event(<#= evnt.Id #>
<#+ if (evnt.Keywords.Length > 0)
{ #>
			,Keywords=<#= String.Join(" | ", evnt.Keywords.Select(k => KeywordsClassName + "." + k)) #>
<#+ } #>
<#+ if (evnt.Task != null)
{ #>
			,Task=Tasks.<#= evnt.Task #>
<#+ } #>
<#+ if (evnt.Opcode != null)
{ #>
			,Opcode=EventOpcode.<#= evnt.Opcode #>
<#+ } #>
<#+ if (evnt.Level != null)
{ #>
			,Level=<#= nameof(EventLevel) + "." + evnt.Level #>
<#+ } #>
<#+ if (evnt.Message != null)
{ #>
			,Message="<#= evnt.Message.Replace("\\", "\\\\").Replace("\"", "\\\"")#>"
<#+ } #>
		)]
		public void <#= evnt.Name #>(<#= String.Join(", ", evnt.Parameters.Select(p => Util.FormatInvariant("{0} {1}", p.IsCustomType ? customTypeTargets[p.Type] : p.Type, p.Name))) #>)
		{
			WriteEvent(<#= evnt.Id #><#+ foreach (var param in evnt.Parameters) { #>, <#= param.Name #> <#+ } #>);
		}
<#+ } #>
	}
}
<#+   

} //WriteEventSource

private void ValidateEventDefinitions(EventDefinitions eventDefinitions)
{
    var duplicateCustomTypes = eventDefinitions.CustomTypes.GroupBy(ct => ct.FullyQualifiedName).Where(g => g.Count() > 1).Select(g => g.Key).ToArray();
	if (duplicateCustomTypes.Length > 0)
    {
		throw new ArgumentException(Util.FormatInvariant(
			"Error validating custom type specification (top-most 'customTypes' property) - duplicate types found: {0}",
			String.Join(", ", duplicateCustomTypes)));
    }

	foreach (var evnt in eventDefinitions.Events)
	{
		var unknownKeywords = evnt.Keywords.Except(eventDefinitions.Keywords).ToArray();
		if (unknownKeywords.Length > 0)
		{
			throw new ArgumentException(Util.FormatInvariant(
				"Error validating event {0} ({1}) - unknown keyword(s) (not defined in the top-most 'keywords' property - note that it is CASE SENSITIVE): {2} ", 
				evnt.Name, evnt.Id, String.Join(", ", unknownKeywords)));
		}

		if (evnt.Task != null && !eventDefinitions.Tasks.Contains(evnt.Task))
		{
			throw new ArgumentException(Util.FormatInvariant(
				"Error validating event {0} ({1}) - unknown task (not defined in the top-most 'tasks' property - note that it is CASE SENSITIVE): {2}",
				evnt.Name, evnt.Id, evnt.Task));
		}

		var parameters = evnt.Parameters.Select(p => p.Name);
		var duplicateParamNames = parameters.GroupBy(p => p).Where(g => g.Count() > 1).Select(g => g.Key).ToArray();
		if (duplicateParamNames.Length > 0)
        {
			throw new ArgumentException(Util.FormatInvariant(
				"Error validating event {0} ({1}) - duplicate parameter name(s) detected: {2}", 
				evnt.Name, evnt.Id, String.Join(", ", duplicateParamNames)));
        }

		var unknownCustomTypes = evnt.Parameters.Where(p => p.IsCustomType).Select(ct => ct.Type).Except(eventDefinitions.CustomTypes.Select(ct => ct.FullyQualifiedName)).ToArray();
		if (unknownCustomTypes.Length > 0)
		{
			throw new ArgumentException(Util.FormatInvariant(
				"Error validating event {0} ({1}) - unknown custom type(s) (not defined in the top-most 'customTypes' property - note that the type name must be fully qualified by its namespace [e.g. 'My.NameSpace.Type'] and it is CASE SENSITIVE): {2}", 
				evnt.Name, evnt.Id, String.Join(", ", unknownCustomTypes)));
		}
	}
}

static class Util
{
	public static string FormatInvariant(string format, params object[] args)
    {
		return String.Format(CultureInfo.InvariantCulture, format, args);
    }

	public static string GetConverterName(string fullyQualifiedType)
    {
		//The chance of someone having separate types that look like A___B and A.B (causing collision here) is so small we'll ignore it
		return "converter" + fullyQualifiedType.Replace(".", "___"); 
    }

	public static string GetConverterType(CustomType customType)
    {
		return Util.FormatInvariant("Func<{0}, {1}>", customType.FullyQualifiedName, customType.TargetType);
    }

	public static string GetCsharpType(string typeCode)
	{
		switch (typeCode)
		{
			case "Boolean": return "bool";
			case "Char": return "char";
			case "UInt16" : return "ushort";
			case "SByte" : return "sbyte";
			case "Byte" : return "byte";
			case "Int16" : return "short";
			case "Int32" : return "int";
			case "UInt32" : return "uint";
			case "Int64" : return "long";
			case "UInt64" : return "ulong";
			case "Single" : return "float";
			case "Double" : return "double";
			case "DateTime" : return "DateTime";
			case "String" : return "string";
			case "GUID" : return "Guid";
			case "IntPtr" : return "IntPtr";
			case "ByteArray" : return "byte[]";
			default: throw new ArgumentException("Invalid parameter type, consult the 'etwNativeType' enumeration in events-schema.json for the list of allowed types:" + typeCode);
		}
	}
}

[DataContract]
class EventDefinitions
{
	[DataMember(Name="class", IsRequired=true)]
    public string Class { get; private set; }
    
	[DataMember(Name="sourceName", IsRequired=true)]
	public string SourceName { get; private set; }
	
	string[] m_tasks;
	[DataMember(Name="tasks")]
	public string[] Tasks 
	{
		get			{return m_tasks ?? new string[0]; }
		private set {m_tasks = value; }
	}
	
	string[] m_keywords;
	[DataMember(Name="keywords")]
	public string[] Keywords 
	{
		get			{return m_keywords ?? new string[0]; } 
		private set {m_keywords = value; }
	}

	CustomType[] m_customTypes;
	[DataMember(Name="customTypes")]
	public CustomType[] CustomTypes
	{
		get			{return m_customTypes ?? new CustomType[0]; }
		private set	{m_customTypes = value; }
	}
 
	EventDefinition[] m_events;
	[DataMember(Name="events", IsRequired=true)]
	public EventDefinition[] Events 
	{
		get			{return m_events ?? new EventDefinition[0]; } 
		private set {m_events = value; }
	}
}

[DataContract]
class EventDefinition
{
	[DataMember(Name="id", IsRequired=true)]
    public int Id { get; private set; }
	
	[DataMember(Name="name", IsRequired=true)]
    public string Name { get; private set; }

	[DataMember(Name="level")]
    private string LevelValue { get; set; }

    public EventLevel? Level { get { return (LevelValue == null) ? null : (EventLevel?)Enum.Parse(typeof(EventLevel), LevelValue);} }

	[DataMember(Name="message")]
    public string Message { get; private set; }

	string[] m_keywords;
	[DataMember(Name="keywords")]
    public string[] Keywords 
	{ 
		get			{return m_keywords ?? new string[0]; } 
		private set {m_keywords = value; }
	}

	[DataMember(Name="task")]
    public string Task { get; private set; }

	[DataMember(Name="opcode")]
    private string OpcodeValue { get; set; }

    public EventOpcode? Opcode { get { return (OpcodeValue == null) ? null : (EventOpcode?)Enum.Parse(typeof(EventOpcode), OpcodeValue); } }

	Parameter[] m_parameters;
	[DataMember(Name="parameters")]
	public Parameter[] Parameters 
	{
		get			{return m_parameters ?? new Parameter[0]; }
		private set	{m_parameters = value; }
	}
}

[DataContract]
class Parameter
{
	[DataMember(Name="name", IsRequired=true)]
	public string Name {get; private set;}

	[DataMember(Name="type")]
	private string TypeValue {get; set;}

	[DataMember(Name="customType")]
	private string CustomTypeNameValue {get; set;}

	public bool IsCustomType {get {return CustomTypeNameValue != null; } }

	public string Type { get { return IsCustomType ? CustomTypeNameValue : Util.GetCsharpType(TypeValue); } }
}

[DataContract]
class CustomType
{
	[DataMember(Name="fullyQualifiedName", IsRequired=true)]
    public string FullyQualifiedName { get; private set; }

	[DataMember(Name="targetType", IsRequired=true)]
    private string TargetTypeValue { get; set; }

	public string TargetType { get { return Util.GetCsharpType(TargetTypeValue); } }
}
#>