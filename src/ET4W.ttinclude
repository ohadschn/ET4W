<#@ assembly name="System.Core"#>
<#@ assembly name="System.Xml"#>
<#@ assembly name="System.Runtime.Serialization"#>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text"#>
<#@ import namespace="System.Collections.Generic"#>
<#@ import namespace="System.Runtime.Serialization" #>
<#@ import namespace="System.Runtime.Serialization.Json" #>
<#@ import namespace="System.Diagnostics.Tracing" #>
<#@ import namespace="System.Globalization" #>
<#+
private void WriteEventSource(string eventsFile, string nameSpace, string baseTypeFullyQualifiedName = null)
{
	baseTypeFullyQualifiedName = baseTypeFullyQualifiedName ?? typeof(EventSource).FullName;
	EventDefinitions eventDefinitions = null;
	var dcjs = new DataContractJsonSerializer(typeof(EventDefinitions));

	//we don't use FileStream directly below in order to support UTF BOM headers
	using (var eventsStream = new MemoryStream(Encoding.UTF8.GetBytes(File.ReadAllText(eventsFile))))
    {
		eventDefinitions = (EventDefinitions)dcjs.ReadObject(eventsStream);
    }
	ValidateEventDefinitions(eventDefinitions);
	var eventClassName = eventDefinitions.Class + "Events"; 
	var eventSourceClassName = eventDefinitions.Class + "EventSource"; 
	var customTypeTargets = eventDefinitions.CustomTypes.ToDictionary(ct => ct.FullyQualifiedName, ct => ct.TargetType);
#>
//--------------------------------------------------------------------------------------------------------------
// <auto-generated> 
// This code was automatically generated by ET4W (https://github.com/ohadschn/ET4W).
// Changes to this file might cause incorrect behavior and will be lost if the code is regenerated. 
// If you wish to customize the code below, please extend the generated partial events class in a separate file.
//
// Generated from:			<#= eventsFile #>
// Generation time:			<#= DateTime.UtcNow.ToString("r") #>
//
// </auto-generated> 
//--------------------------------------------------------------------------------------------------------------

using System;
using System.Diagnostics.Tracing;

namespace <#= nameSpace #>
{	
	//wrapper event class
	public partial class <#= eventClassName #>
	{	
		//custom type converters (if exist)
<#+
		foreach (var customType in eventDefinitions.CustomTypes)
{#>
		private <#= Util.GetConverterType(customType) #> m_<#= Util.GetConverterName(customType.FullyQualifiedName) #>;
<#+ } #>

		//common parameter generators (if exist)
<#+
		foreach (var commonParam in eventDefinitions.CommonParameters.Where(cp => cp.Generated))
{#>
		private <#= Util.GetGeneratorType(commonParam) #> m_<#= Util.GetGeneratorName(commonParam) #>;
<#+ } #>
		
		//ctor
		public <#= eventClassName #>(<#= String.Join(", ", 
			eventDefinitions.CustomTypes.Select(ct => Util.GetParamSignature(Util.GetConverterType(ct), Util.GetConverterName(ct.FullyQualifiedName)))
			.Union(eventDefinitions.CommonParameters.Where(cp => cp.Generated).Select(cp => Util.GetParamSignature(Util.GetGeneratorType(cp), Util.GetGeneratorName(cp))))) #>)
		{
			//converter assignments (if exist)
<#+
		foreach (var customType in eventDefinitions.CustomTypes)
{#>
			m_<#= Util.GetConverterName(customType.FullyQualifiedName) #> = <#= Util.GetConverterName(customType.FullyQualifiedName) #>;
<#+ } #>

			//generator assignments (if exist)
<#+
		foreach (var generatedParam in eventDefinitions.CommonParameters.Where(cp => cp.Generated))
{#>
			m_<#= Util.GetGeneratorName(generatedParam) #> = <#= Util.GetGeneratorName(generatedParam) #>;
<#+ } #>
		}

		//wrapper event methods

<#+
		foreach (var eventDef in eventDefinitions.Events)
{ #>
		public void <#= eventDef.Name #>(<#= String.Join(", ", 
		Util.GetCombinedParameters(eventDef, eventDefinitions, EventCombinedParams.NonGenerated).Select(cp => Util.GetParamSignature(cp.Type, cp.Name))) #>)
		{
			<#= eventSourceClassName #>.Log.<#= eventDef.Name #>(<#= String.Join(", ", 
					Util.GetCombinedParameters(eventDef, eventDefinitions, EventCombinedParams.Both).Select(Util.GetEtwParamCall)) #>);
		}
<#+ } #>
	}

	//event source
	[EventSource(Name = "<#= eventDefinitions.SourceName #>")]
	public sealed class <#= eventSourceClassName #> : <#= baseTypeFullyQualifiedName #>
	{
		//static log property for easy access
		public static readonly <#= eventSourceClassName #> Log = new <#= eventSourceClassName #>();

		//event keywords
		public sealed class Keywords
		{
			private Keywords() {}
<#+ 
	int keywordValue = 1;
	foreach (var keyword in eventDefinitions.Keywords)
    { #>
			public const EventKeywords <#= keyword #> = (EventKeywords) <#= keywordValue #>;
<#+ 
		keywordValue *= 2;
	} #>
		}

		//event tasks
		public sealed class Tasks
		{
			private Tasks() {}
<#+ 
	int taskValue = 1;
	foreach (var keyword in eventDefinitions.Tasks)
    { #>
			public const EventTask <#= keyword #> = (EventTask) <#= taskValue++ #>;
<#+ } #>
		}

		//ETW event methods

<#+ 
	foreach (var eventDef in eventDefinitions.Events)
	{ #>
		[Event(<#= eventDef.Id #>
<#+ if (eventDef.Keywords.Length > 0)
{ #>
			,Keywords=<#= String.Join(" | ", eventDef.Keywords.Select(k => "Keywords." + k)) #>
<#+ } #>
<#+ if (eventDef.Task != null)
{ #>
			,Task=Tasks.<#= eventDef.Task #>
<#+ } #>
<#+ if (eventDef.Opcode != null)
{ #>
			,Opcode=EventOpcode.<#= eventDef.Opcode #>
<#+ } #>
<#+ if (eventDef.Level != null)
{ #>
			,Level=<#= nameof(EventLevel) + "." + eventDef.Level #>
<#+ } #>
<#+ if (eventDef.Message != null)
{ #>
			,Message="<#= eventDef.Message.Replace("\\", "\\\\").Replace("\"", "\\\"")#>"
<#+ } #>
		)]
		public void <#= eventDef.Name #>(<#= String.Join(", ", 	Util.GetCombinedParameters(eventDef, eventDefinitions, EventCombinedParams.Both)
																.Select(p => Util.GetParamSignature(p.IsCustomType ? customTypeTargets[p.Type] : p.Type, p.Name))) #>)
		{
			WriteEvent(<#= eventDef.Id #><#+ foreach (var param in Util.GetCombinedParameters(eventDef, eventDefinitions, EventCombinedParams.Both)) { #>, <#= param.Name #><#+ } #>);
		}
<#+ } #>
	}
}
<#+   

} //WriteEventSource

private void ValidateEventDefinitions(EventDefinitions eventDefinitions)
{
    var duplicateCustomTypes = eventDefinitions.CustomTypes.GroupBy(ct => ct.FullyQualifiedName).Where(g => g.Count() > 1).Select(g => g.Key).ToArray();
	if (duplicateCustomTypes.Length > 0)
    {
		throw new ArgumentException(Util.FormatInvariant(
			"Error validating custom type specification (top-most 'customTypes' property) - duplicate types found: {0}",
			String.Join(", ", duplicateCustomTypes)));
    }

	var duplicateCommonParameters = eventDefinitions.CommonParameters.GroupBy(cp => cp.Name).Where(g => g.Count() > 1).Select(g => g.Key).ToArray();
	if (duplicateCommonParameters.Length > 0)
    {
		throw new ArgumentException(Util.FormatInvariant(
			"Error validating common parameter specification (top-most 'commonParameters' property) - duplicate names found: {0}",
			String.Join(", ", duplicateCommonParameters)));
    }

	var unknownCommonCustomTypes = eventDefinitions.CommonParameters.Where(p => p.IsCustomType).Select(ct => ct.Type)
																	.Except(eventDefinitions.CustomTypes.Select(ct => ct.FullyQualifiedName)).ToArray();
	if (unknownCommonCustomTypes.Length > 0)
	{
		throw new ArgumentException(Util.FormatInvariant(
			"Error validating common parameter specification (top-most 'commonParameters' property) - unknown custom type(s) (not defined in the top-most 'customTypes' property - note that the type name must be fully qualified by its namespace [e.g. 'My.NameSpace.Type'] and it is CASE SENSITIVE): {0}", 
			String.Join(", ", unknownCommonCustomTypes)));
	}

	foreach (var eventDef in eventDefinitions.Events)
	{
		var unknownKeywords = eventDef.Keywords.Except(eventDefinitions.Keywords).ToArray();
		if (unknownKeywords.Length > 0)
		{
			throw new ArgumentException(GetEventValidationErrorMessage(eventDef, 
				"unknown keyword(s) (not defined in the top-most 'keywords' property - note that it is CASE SENSITIVE): " + String.Join(", ", unknownKeywords)));
		}

		if (eventDef.Task != null && !eventDefinitions.Tasks.Contains(eventDef.Task))
		{
			throw new ArgumentException(GetEventValidationErrorMessage(eventDef, 
				"unknown task (not defined in the top-most 'tasks' property - note that it is CASE SENSITIVE): " + eventDef.Task));
		}

		var duplicateParamNames = eventDef.Parameters.GroupBy(p => p.Name).Where(g => g.Count() > 1).Select(g => g.Key).ToArray();
		if (duplicateParamNames.Length > 0)
        {
			throw new ArgumentException(GetEventValidationErrorMessage(eventDef, "duplicate parameter name(s) detected: " + String.Join(", ", duplicateParamNames)));
        }

		var unknownCustomTypes = eventDef.Parameters.Where(p => p.IsCustomType).Select(ct => ct.Type).Except(eventDefinitions.CustomTypes.Select(ct => ct.FullyQualifiedName)).ToArray();
		if (unknownCustomTypes.Length > 0)
		{
			throw new ArgumentException(GetEventValidationErrorMessage(eventDef, 
				"unknown custom type(s) (not defined in the top-most 'customTypes' property - note that the type name must be fully qualified by its namespace [e.g. 'My.NameSpace.Type'] and it is CASE SENSITIVE): " + 
				String.Join(", ", unknownCustomTypes)));
		}

		var collidingParams = eventDef.Parameters.Select(p => p.Name).Intersect(eventDefinitions.CommonParameters.Select(cp => cp.Name)).ToArray();
		if (collidingParams.Length > 0)
        {
			throw new ArgumentException(GetEventValidationErrorMessage(eventDef, 
				"the following parameter name(s) collide(s) with common parameter name(s) (as defined in the top-most 'commonParameters' property): " + 
				String.Join(", ", collidingParams)));
        }

		if (eventDef.Opcode != null)
        {
			if (eventDef.Task == null)
            {
				Warning(GetEventValidationErrorMessage(eventDef, 
					"Opcode defined without task (see http://blogs.msmvps.com/kathleen/2014/01/24/how-are-event-parameters-best-used-to-create-an-intuitive-custom-evnetsourcetrace/)"));
            }
			else if (!String.Equals(eventDef.Task + eventDef.Opcode, eventDef.Name, StringComparison.Ordinal))
            {
				Warning(GetEventValidationErrorMessage(eventDef, 
					"Opcode and Task are defined, but the event's name is not their concatenation (see http://blogs.msmvps.com/kathleen/2014/01/24/how-are-event-parameters-best-used-to-create-an-intuitive-custom-evnetsourcetrace/)"));
            }
        }
	}
}

static string GetEventValidationErrorMessage(EventDefinition eventDef, string message)
{
	return Util.FormatInvariant("Error validating event {0} ({1}) - {2}", eventDef.Name, eventDef.Id, message);
}

enum EventCombinedParams
{
	None,
	Generated,
	NonGenerated,
	Both
}

static class Util
{
	public static string FormatInvariant(string format, params object[] args)
    {
		return String.Format(CultureInfo.InvariantCulture, format, args);
    }

	public static string GetParamSignature(string type, string name)
    {
		return FormatInvariant("{0} {1}", type, name);
    }

	public static string GetEtwParamCall(Parameter param)
    {
		var commonParam = param as CommonParameter;
		string paramValue = (commonParam != null && commonParam.Generated) ? "m_"+GetGeneratorName(param)+"()" : param.Name;
		return param.IsCustomType ? Util.FormatInvariant("{0}({1})", "m_"+Util.GetConverterName(param.Type), paramValue) : paramValue;
    }

	public static string GetConverterName(string fullyQualifiedType)
    {
		return GetSanitizedIdentifier(fullyQualifiedType, "converter");
    }

	public static string GetConverterType(CustomType customType)
    {
		return FormatInvariant("Func<{0}, {1}>", customType.FullyQualifiedName, customType.TargetType);
    }

	public static string GetGeneratorName(Parameter param)
    {
		return GetSanitizedIdentifier(param.Name, "generator");
    }
	
	public static string GetGeneratorType(Parameter param)
    {
		return FormatInvariant("Func<{0}>", param.Type);
    }

	private static string GetSanitizedIdentifier(string typeName, string identifierType)
    {
		//The chances of someone having separate types that look like A___B and A.B (causing collision here) are so small that we'll ignore them here for simplicity
		return typeName.Replace(".", "___") + "___" + identifierType;
    }

	public static IEnumerable<Parameter> GetCombinedParameters(EventDefinition eventDef, EventDefinitions eventDefs, EventCombinedParams combinedParams)
    {
		IEnumerable<Parameter> commonParams;
        switch (combinedParams)
        {
            case EventCombinedParams.None:
				commonParams = Enumerable.Empty<Parameter>();
				break;
			case EventCombinedParams.Generated:
				commonParams = eventDefs.CommonParameters.Where(cp => cp.Generated);
				break;
			case EventCombinedParams.NonGenerated:
				commonParams = eventDefs.CommonParameters.Where(cp => !cp.Generated);
				break;
			case EventCombinedParams.Both:
				commonParams = eventDefs.CommonParameters;
				break;
			default:
				throw new ArgumentException("Invalid EventCombinedParams value: " + combinedParams, "combinedParams");
        }
		return commonParams.Union(eventDef.Parameters);
    }

	public static string GetCsharpType(string typeCode)
	{
		switch (typeCode)
		{
			case "Boolean": return "bool";
			case "Char": return "char";
			case "UInt16" : return "ushort";
			case "SByte" : return "sbyte";
			case "Byte" : return "byte";
			case "Int16" : return "short";
			case "Int32" : return "int";
			case "UInt32" : return "uint";
			case "Int64" : return "long";
			case "UInt64" : return "ulong";
			case "Single" : return "float";
			case "Double" : return "double";
			case "DateTime" : return "DateTime";
			case "String" : return "string";
			case "GUID" : return "Guid";
			case "IntPtr" : return "IntPtr";
			case "ByteArray" : return "byte[]";
			default: throw new ArgumentException("Invalid parameter type, consult the 'etwNativeType' enumeration in events-schema.json for the list of allowed types:" + typeCode);
		}
	}
}

[DataContract]
class EventDefinitions
{
	[DataMember(Name="class", IsRequired=true)]
    public string Class { get; private set; }
    
	[DataMember(Name="sourceName", IsRequired=true)]
	public string SourceName { get; private set; }
	
	string[] m_tasks;
	[DataMember(Name="tasks")]
	public string[] Tasks 
	{
		get			{return m_tasks ?? new string[0]; }
		private set {m_tasks = value; }
	}
	
	string[] m_keywords;
	[DataMember(Name="keywords")]
	public string[] Keywords 
	{
		get			{return m_keywords ?? new string[0]; } 
		private set {m_keywords = value; }
	}

	CustomType[] m_customTypes;
	[DataMember(Name="customTypes")]
	public CustomType[] CustomTypes
	{
		get			{return m_customTypes ?? new CustomType[0]; }
		private set	{m_customTypes = value; }
	}

	CommonParameter[] m_commonParameters;
	[DataMember(Name="commonParameters")]
	public CommonParameter[] CommonParameters
    {
		get			{return m_commonParameters ?? new CommonParameter[0]; }
		private set	{m_commonParameters = value; }
    }
 
	EventDefinition[] m_events;
	[DataMember(Name="events", IsRequired=true)]
	public EventDefinition[] Events 
	{
		get			{return m_events ?? new EventDefinition[0]; } 
		private set {m_events = value; }
	}
}

[DataContract]
class EventDefinition
{
	[DataMember(Name="id", IsRequired=true)]
    public int Id { get; private set; }
	
	[DataMember(Name="name", IsRequired=true)]
    public string Name { get; private set; }

	[DataMember(Name="level")]
    private string LevelValue { get; set; }

    public EventLevel? Level { get { return (LevelValue == null) ? null : (EventLevel?)Enum.Parse(typeof(EventLevel), LevelValue);} }

	[DataMember(Name="message")]
    public string Message { get; private set; }

	string[] m_keywords;
	[DataMember(Name="keywords")]
    public string[] Keywords 
	{ 
		get			{return m_keywords ?? new string[0]; } 
		private set {m_keywords = value; }
	}

	[DataMember(Name="task")]
    public string Task { get; private set; }

	[DataMember(Name="opcode")]
    private string OpcodeValue { get; set; }

    public EventOpcode? Opcode { get { return (OpcodeValue == null) ? null : (EventOpcode?)Enum.Parse(typeof(EventOpcode), OpcodeValue); } }

	Parameter[] m_parameters;
	[DataMember(Name="parameters")]
	public Parameter[] Parameters 
	{
		get			{return m_parameters ?? new Parameter[0]; }
		private set	{m_parameters = value; }
	}
}

[DataContract]
class Parameter
{
	[DataMember(Name="name", IsRequired=true)]
	public string Name {get; private set;}

	[DataMember(Name="type")]
	private string TypeValue {get; set;}

	[DataMember(Name="customType")]
	private string CustomTypeNameValue {get; set;}

	public bool IsCustomType {get {return CustomTypeNameValue != null; } }

	public string Type { get { return IsCustomType ? CustomTypeNameValue : Util.GetCsharpType(TypeValue); } }
}

[DataContract]
class CustomType
{
	[DataMember(Name="fullyQualifiedName", IsRequired=true)]
    public string FullyQualifiedName { get; private set; }

	[DataMember(Name="targetType", IsRequired=true)]
    private string TargetTypeValue { get; set; }

	public string TargetType { get { return Util.GetCsharpType(TargetTypeValue); } }
}

[DataContract]
class CommonParameter : Parameter
{
	[DataMember(Name="generated")]
    public bool Generated { get; private set; }
}
#>