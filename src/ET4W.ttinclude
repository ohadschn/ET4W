<#@ assembly name="System.Core"#>
<#@ assembly name="System.Xml"#>
<#@ assembly name="System.Runtime.Serialization"#>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text"#>
<#@ import namespace="System.Runtime.Serialization" #>
<#@ import namespace="System.Runtime.Serialization.Json" #>
<#@ import namespace="System.Diagnostics.Tracing" #>
<#+
const string KeywordsClassName = "Keywords";
private void WriteEventSource(string eventsFile, string nameSpace, Type baseType = null)
{
	baseType = baseType ?? typeof(EventSource);
	EventDefinitions eventDefinitions = null;
	var dcjs = new DataContractJsonSerializer(typeof(EventDefinitions));

	//we don't use FileStream directly below in order to support UTF BOM headers
	using (var eventsStream = new MemoryStream(Encoding.UTF8.GetBytes(File.ReadAllText(eventsFile))))
    {
		eventDefinitions = (EventDefinitions)dcjs.ReadObject(eventsStream);
    }
	var eventSourceClassName = eventDefinitions.Class + "EventSource";
#>
using System;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Tracing;
using System.Globalization;
using System.Linq;
using System.Net;

namespace <#= nameSpace #>
{
	public partial class <#= eventDefinitions.Class #>Events
	{
<#+ 
		foreach (var evnt in eventDefinitions.Events)
{ #>
			public void <#= evnt.Name #>()
			{
				<#= eventSourceClassName #>.Log.<#= evnt.Name #>();
			}
<#+ } #>

			[EventSource(Name = "<#= eventDefinitions.SourceName #>")]
			private sealed class <#= eventSourceClassName #> : <#= baseType.FullName #>
			{
				public static readonly <#= eventSourceClassName #> Log = new  <#= eventSourceClassName #>();

				public sealed class Keywords
				{
					private Keywords() {}
<#+ 
	int keywordValue = 1;
	foreach (var keyword in eventDefinitions.Keywords)
    { #>
					public const EventKeywords <#= keyword #> = (EventKeywords) <#= keywordValue #>;
<#+ 
	keywordValue *= 2;
	} #>
				}

				public sealed class Tasks
				{
					private Tasks() {}
<#+ 
	int taskValue = 1;
	foreach (var keyword in eventDefinitions.Tasks)
    { #>
					public const EventTask <#= keyword #> = (EventTask) <#= taskValue++ #>;
<#+ } #>
				}

<#+ 
	foreach (var evnt in eventDefinitions.Events)
	{ #>
				[Event(
					<#= evnt.Id #>, 
<#+ if (evnt.Keywords != null && evnt.Keywords.Length > 0) 
	{ #>
					Keywords=<#= String.Join(" | ", evnt.Keywords.Select(k => KeywordsClassName + "." + k)) #>,
<#+ } #>
<#+ if (evnt.Task != null)
	{ #>
					Task=Tasks.<#= evnt.Task #>,
<#+ } #>
<#+ if (evnt.Opcode != null)
	{ #>
					Opcode=EventOpcode.<#= evnt.Opcode #>,
<#+ } #>					Level=<#= nameof(EventLevel) + "." + evnt.Level #>,
					Message="<#= evnt.Message == null ? null : evnt.Message.Replace("\\", "\\\\").Replace("\"", "\\\"")#>")]
				public void <#= evnt.Name #>()
				{
				}
<#+ } #>
			}
	}
}
<#+   
	
} //WriteEventSource

[DataContract]
class EventDefinitions
{
	[DataMember(Name="class", IsRequired=true)]
    public string Class { get; private set; }
    
	[DataMember(Name="sourceName", IsRequired=true)]
	public string SourceName { get; private set; }
	
	[DataMember(Name="tasks")]
	public string[] Tasks {get; private set;}
	
	[DataMember(Name="keywords")]
	public string[] Keywords {get; private set;}
 
	[DataMember(Name="events", IsRequired=true)]
	public EventDefinition[] Events {get; private set;}
}

[DataContract]
class EventDefinition
{
	[DataMember(Name="id", IsRequired=true)]
    public int Id { get; private set; }
	
	[DataMember(Name="name", IsRequired=true)]
    public string Name { get; private set; }

	[DataMember(Name="level")]
    private string LevelValue { get; set; }

    public EventLevel Level { get { return (LevelValue == null) ? EventLevel.Informational : (EventLevel)Enum.Parse(typeof(EventLevel), LevelValue);} }

	[DataMember(Name="message")]
    public string Message { get; private set; }

	[DataMember(Name="keywords")]
    public string[] Keywords { get; private set; }

	[DataMember(Name="task")]
    public string Task { get; private set; }

	[DataMember(Name="opcode")]
    private string OpcodeValue { get; set; }

    public EventOpcode? Opcode { get { return (OpcodeValue == null) ? null : (EventOpcode?)Enum.Parse(typeof(EventOpcode), OpcodeValue); } }
}
#>