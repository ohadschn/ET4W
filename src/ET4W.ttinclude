<#@ assembly name="System.Core"#>
<#@ assembly name="System.Xml"#>
<#@ assembly name="System.Runtime.Serialization"#>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text"#>
<#@ import namespace="System.Runtime.Serialization" #>
<#@ import namespace="System.Runtime.Serialization.Json" #>
<#@ import namespace="System.Diagnostics.Tracing" #>
<#@ import namespace="System.Globalization" #>
//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// This code was generated by ET4W (https://github.com/ohadschn/ET4W).
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated. 
// If you wish to customize the code, extend the partial Events class.
// </auto-generated> 
//-------------------------------------------------------------------------------------------------
<#+
const string KeywordsClassName = "Keywords";
private void WriteEventSource(string eventsFile, string nameSpace, Type baseType = null)
{
	baseType = baseType ?? typeof(EventSource);
	EventDefinitions eventDefinitions = null;
	var dcjs = new DataContractJsonSerializer(typeof(EventDefinitions));

	//we don't use FileStream directly below in order to support UTF BOM headers
	using (var eventsStream = new MemoryStream(Encoding.UTF8.GetBytes(File.ReadAllText(eventsFile))))
    {
		eventDefinitions = (EventDefinitions)dcjs.ReadObject(eventsStream);
    }
	ValidateEventDefinitions(eventDefinitions);
	var eventSourceClassName = eventDefinitions.Class + "EventSource";
#>
using System;
using System.Diagnostics.Tracing;

namespace <#= nameSpace #>
{
	public partial class <#= eventDefinitions.Class #>Events
	{
<#+ 
		foreach (var evnt in eventDefinitions.Events)
{ #>
		public void <#= evnt.Name #>(<#= String.Join(", ", evnt.Parameters.Select(GetParameterSignatureRepresentation)) #>)
		{
			<#= eventSourceClassName #>.Log.<#= evnt.Name #>(<#= String.Join(", ", evnt.Parameters.Select(p => p.Name)) #>);
		}
<#+ } #>
	}

	[EventSource(Name = "<#= eventDefinitions.SourceName #>")]
	public sealed class <#= eventSourceClassName #> : <#= baseType.FullName #>
	{
		public static readonly <#= eventSourceClassName #> Log = new <#= eventSourceClassName #>();

		public sealed class Keywords
		{
			private Keywords() {}
<#+ 
	int keywordValue = 1;
	foreach (var keyword in eventDefinitions.Keywords)
    { #>
			public const EventKeywords <#= keyword #> = (EventKeywords) <#= keywordValue #>;
<#+ 
	keywordValue *= 2;
	} #>
		}

		public sealed class Tasks
		{
			private Tasks() {}
<#+ 
	int taskValue = 1;
	foreach (var keyword in eventDefinitions.Tasks)
    { #>
			public const EventTask <#= keyword #> = (EventTask) <#= taskValue++ #>;
<#+ } #>
		}

<#+ 
	foreach (var evnt in eventDefinitions.Events)
	{ #>
		[Event(<#= evnt.Id #>
<#+ if (evnt.Keywords.Length > 0)
{ #>
			,Keywords=<#= String.Join(" | ", evnt.Keywords.Select(k => KeywordsClassName + "." + k)) #>
<#+ } #>
<#+ if (evnt.Task != null)
{ #>
			,Task=Tasks.<#= evnt.Task #>
<#+ } #>
<#+ if (evnt.Opcode != null)
{ #>
			,Opcode=EventOpcode.<#= evnt.Opcode #>
<#+ } #>
<#+ if (evnt.Level != null)
{ #>
			,Level=<#= nameof(EventLevel) + "." + evnt.Level #>
<#+ } #>
<#+ if (evnt.Message != null)
{ #>
			,Message="<#= evnt.Message.Replace("\\", "\\\\").Replace("\"", "\\\"")#>"
<#+ } #>
		)]
		public void <#= evnt.Name #>(<#= String.Join(", ", evnt.Parameters.Select(GetParameterSignatureRepresentation)) #>)
		{
			WriteEvent(<#= evnt.Id #><#= evnt.Parameters.Length > 0 ? ", " : "" #><#= String.Join(", ", evnt.Parameters.Select(p => p.Name)) #>);
		}
<#+ } #>
	}
}
<#+   
	
} //WriteEventSource

private void ValidateEventDefinitions(EventDefinitions eventDefinitions)
{
	foreach (var evnt in eventDefinitions.Events)
	{
		var unknownKeywords = evnt.Keywords.Except(eventDefinitions.Keywords).ToArray();
		if (unknownKeywords.Length > 0)
		{
			throw new ArgumentException(String.Format(CultureInfo.InvariantCulture,
				 "Error validating event {0} ({1}) - Unknown keyword(s) (not defined in the top-most 'keywords' property): {2}", 
				evnt.Name, evnt.Id, String.Join(", ", unknownKeywords)));
		}

		if (evnt.Task != null && !eventDefinitions.Tasks.Contains(evnt.Task))
		{
			throw new ArgumentException(String.Format(CultureInfo.InvariantCulture,
				"Error validating event {0} ({1}) - Unknown task (not defined in the top-most 'tasks' property): {2}",
				evnt.Name, evnt.Id, evnt.Task));
		}

		var parameters = evnt.Parameters.Select(p => p.Name);
		var duplicateParamNames = parameters.GroupBy(p => p).Where(g => g.Count() > 1).Select(g => g.Key).ToArray();
		if (duplicateParamNames.Length > 0)
        {
			throw new ArgumentException(String.Format(CultureInfo.InvariantCulture,
				"Error validating event {0} ({1}) - duplicate parameter name(s) detected: {2}", 
				evnt.Name, evnt.Id, String.Join(", ", duplicateParamNames)));
        }
	}
}

private string GetParameterSignatureRepresentation(Parameter parameter)
{
	return String.Format(System.Globalization.CultureInfo.InvariantCulture, "{0} {1}", parameter.Type, parameter.Name);
}

[DataContract]
class EventDefinitions
{
	[DataMember(Name="class", IsRequired=true)]
    public string Class { get; private set; }
    
	[DataMember(Name="sourceName", IsRequired=true)]
	public string SourceName { get; private set; }
	
	string[] m_tasks;
	[DataMember(Name="tasks")]
	public string[] Tasks 
	{
		get			{return m_tasks ?? new string[0]; }
		private set {m_tasks = value; }
	}
	
	string[] m_keywords;
	[DataMember(Name="keywords")]
	public string[] Keywords 
	{
		get			{return m_keywords ?? new string[0]; } 
		private set {m_keywords = value; }
	}
 
	EventDefinition[] m_events;
	[DataMember(Name="events", IsRequired=true)]
	public EventDefinition[] Events 
	{
		get			{return m_events ?? new EventDefinition[0]; } 
		private set {m_events = value; }
	}
}

[DataContract]
class EventDefinition
{
	[DataMember(Name="id", IsRequired=true)]
    public int Id { get; private set; }
	
	[DataMember(Name="name", IsRequired=true)]
    public string Name { get; private set; }

	[DataMember(Name="level")]
    private string LevelValue { get; set; }

    public EventLevel? Level { get { return (LevelValue == null) ? null : (EventLevel?)Enum.Parse(typeof(EventLevel), LevelValue);} }

	[DataMember(Name="message")]
    public string Message { get; private set; }

	string[] m_keywords;
	[DataMember(Name="keywords")]
    public string[] Keywords 
	{ 
		get			{return m_keywords ?? new string[0]; } 
		private set {m_keywords = value; }
	}

	[DataMember(Name="task")]
    public string Task { get; private set; }

	[DataMember(Name="opcode")]
    private string OpcodeValue { get; set; }

    public EventOpcode? Opcode { get { return (OpcodeValue == null) ? null : (EventOpcode?)Enum.Parse(typeof(EventOpcode), OpcodeValue); } }

	Parameter[] m_parameters;
	[DataMember(Name="parameters")]
	public Parameter[] Parameters 
	{
		get			{return m_parameters ?? new Parameter[0]; }
		private set	{m_parameters = value; }
	}
}

[DataContract]
class Parameter
{
	[DataMember(Name="name", IsRequired=true)]
	public string Name {get; private set;}

	[DataMember(Name="type")]
	private string TypeValue {get; set;}

	public string Type { get { return GetCsharpType(TypeValue); } }
	
	private string GetCsharpType(string typeCode)
    {
		switch (typeCode)
		{
			case "Boolean": return "bool";
			case "Char": return "char";
			case "UInt16" : return "ushort";
			case "SByte" : return "sbyte";
			case "Byte" : return "byte";
			case "Int16" : return "short";
			case "Int32" : return "int";
			case "UInt32" : return "uint";
			case "Int64" : return "long";
			case "UInt64" : return "ulong";
			case "Single" : return "float";
			case "Double" : return "double";
			case "DateTime" : return "DateTime";
			case "String" : return "string";
			case "GUID" : return "Guid";
			case "IntPtr" : return "IntPtr";
			case "ByteArray" : return "byte[]";
			default: throw new ArgumentException("Invalid parameter type, consult events-schema.json for the list of allowed types:" + TypeValue);
		}
    }
}
#>